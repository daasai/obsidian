# 研发效能-1~2月盘点

1. 研发周期有提升，TODO：超过15日（颗粒度大）的需求治理，
2. 工时，
3. 由于线上bug引起系统服务异常，已经影响业务或可能影响业务的，必须及时上报潜火铺。
4. 履约资金安全的缺陷占比比较高，需求没确认？
5. 小需求的技术方案拉齐
6. Android、IOS 工时

# 贝易转

1. 

## 效能度量：

1~2月度量报告的跟进，待改进项以及跟进措施

1. 需求复杂度颗粒度治理：
    1. 需求颗粒度过大，拆解不够，管理精细度不够
    2. 不紧急需求的处理，先录入，择机择时投入研发， 结果就是一直放在那
2. 线上bug：
    1. 事件必复盘必跟进，防微杜渐
    2. 潜火铺应报尽报
3. 技术需求的投入占比：343
4. 上线延期率：
    1. 上线时间的误差
    2. 代码提交联动上线卡片：流水线

## 贝壳OCR平台

to交易审核的价值

1. 备件检验：自动识别备件缺损、污损（无关水印、印章）等，在用户上传时直接提示重提，提升一次审核通过率
2. 备件增强：当下存在很多清晰度、角度倾斜等，
3. 智能识别（数据结构化）:  相对传统OCR基于人工标注识别区域的方式，AI+OCR希望去人工标注化，以适配同类备件在不同城市、不同年代的差别，提升备件识别的应用效果

### 对于AI多栈的思考：

“以后不会存在程序员这种职位了，只要会说话， 人人都会具备程序员的能力” ——李彦宏

关于未来程序员是否会继续存在，我想这个问题不应该被简单理解。如果回顾整个计算机发展历程，从穿孔卡片输入的机器语言，到汇编、再到当下一系列高级语言，有两个规律：

1. 编程语言与自然语言间的差异不断缩小，直到GPT出现使得我们可以通过自然语言直接与计算机交互；
2. 软件复杂度指数级提升，随着人类对物理世界的数字化不断深入，作为数字化载体的软件系统也变的越来越复杂；
3. 因为2，为了应对复杂度的快速提升，软件工程中的分工越来越细，工种越来越多，协作越来越复杂。（记得刚学编程时一个人就可以完成一套图书借阅系统，而现在需要至少4~5个不同专业伙伴的一起完成。）

观察当下AIGC的发展（比如codelink、baidu comate等），可以代码生成、修正、整理和解释代码等一系列工作，使得1的狭义编程的门槛被革命性降低，未来纯coding的工作将被大量取代。

但“2”的复杂度仍需要人去应对，人们需要思考现实中的问题如何被拆解、澄清、验证，最后变成一系列prompt….从这个层面讲，程序员或许仍会存在，而更偏向于需求理解、系统分析和设计等领域。

### 多栈落地的理想画面大概什么样呢？核心的难点大概是啥？

前期跟项旭也探讨了相关的内容，当下还是比较初阶的认知：

画面：结合系统架构、AIGC、低代码的能力，逐步将大量的、简单需求开发剥离出来，通过AI降低不同工种的门槛，从而实现“一岗多能”。比如：支付通道接入，可以根据后端代码AIGC自动化测试脚本，研发可以主导整个项目； 钱包收银台新支付工具上线，可以根据前端交互AIGC后端代码，前端同学主导整个项目。

核心挑战：

1. AIGC的效果，从现在codelink应用落地看，生成相对模板化、标准化的代码效果不错；但生成有复杂上下文的、系统级的代码效果不太理想，或者需要人工完成很多前期沟通、设计和拆解。所以，“多栈”适合先从通道接入、管理后台、钱包组件等标准化场景切入，随着模型成熟再逐步向复杂场景延伸。
2. 工程工具和流程支持，需要设计与“多栈”匹配的工程化支撑。这部分可以在多栈项目里解决。